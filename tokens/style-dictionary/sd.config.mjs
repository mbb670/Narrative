import StyleDictionary from 'style-dictionary';

// ---------- small helpers ----------
const kebab = (str) =>
  String(str)
    // IMPORTANT: no "i" flag here; we only split lower/digit → UPPER boundaries
    .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
    .replace(/[\s_]+/g, "-")
    .toLowerCase();

const toVarNameFromPath = (pathArr) => `--${pathArr.map(kebab).join("-")}`;

// turn "{a.b.c}" → "var(--a-b-c)"
const refToVar = (val) => {
  if (typeof val === "string") {
    const m = val.match(/^\{([^}]+)\}$/);
    if (m) return `var(--${kebab(m[1].replace(/\./g, "-"))})`;
  }
  return val;
};

// serialize var declarations (sorted for stable diffs)
const decls = (list) =>
  list
    .slice()
    .sort((a, b) =>
      toVarNameFromPath(a.path).localeCompare(toVarNameFromPath(b.path))
    )
    .map((t) => {
      const raw = t.original?.value ?? t.value;
      const v =
        typeof raw === "string" && /^\{.+\}$/.test(raw) ? refToVar(raw) : t.value;
      return `  ${toVarNameFromPath(t.path)}: ${v};`;
    })
    .join("\n");

// pull collection + set from token.filePath
const metaFromFile = (t) => {
  const fp = t.filePath.replace(/\\+/g, "/");
  const m = fp.match(/\/tokens\/raw\/([^/]+)\/([^/]+)\.json$/i);
  return {
    collection: m ? m[1] : "global",
    set: m ? m[2] : "default",
  };
};

// ---------- register the custom format ----------
StyleDictionary.registerFormat({
  name: "nw/css-collections",
  format: ({ dictionary }) => {
    let out = `/* Auto-generated by Style Dictionary. Do not edit directly. */\n\n`;

    const all = dictionary.allTokens;

    const isStyles = (t) =>
      t.filePath.replace(/\\+/g, "/").includes("/tokens/raw/styles/");
    // Treat ANY object **or array** as composite (exclude from :root vars)
    const isComposite = (t) =>
      typeof t.value === "object" && t.value !== null;

    // Vars come from non-styles, non-composite tokens
    const varTokens = all.filter((t) => !isStyles(t) && !isComposite(t));

    // --- partition by collection ---
    const globals = [];
    const breakpoints = { mobile: [], tablet: [], desktop: [] };
    const others = {}; // { collection: { default:[], setName:[] } }
    const modes = {}; // { setName: [] }

    for (const t of varTokens) {
      const { collection, set } = metaFromFile(t);
      if (collection === "global") globals.push(t);
      else if (collection === "breakpoint") (breakpoints[set] ||= []).push(t);
      else if (collection === "mode") (modes[set] ||= []).push(t);
      else if (collection === "styles") {
        // ignored for vars
      } else {
        (others[collection] ||= {});
        (others[collection][set] ||= []).push(t);
      }
    }

    const section = (title, body) =>
      body.trim() ? `/* ${title} */\n${body}\n\n` : "";

    // 1. Global
    if (globals.length) {
      out += section("Global", `:root {\n${decls(globals)}\n}`);
    }

    // 2–4. Breakpoints
    const mq = {
      tablet: "(min-width: 640px)",
      desktop: "(min-width: 1024px)",
    };
    if (breakpoints.mobile?.length) {
      out += section("Breakpoint: mobile", `:root {\n${decls(breakpoints.mobile)}\n}`);
    }
    for (const bp of ["tablet", "desktop"]) {
      const list = breakpoints[bp] || [];
      if (!list.length) continue;
      out += section(
        `Breakpoint: ${bp}`,
        `@media ${mq[bp]} {\n  :root {\n${decls(list)
          .split("\n")
          .map((l) => "    " + l)
          .join("\n")}\n  }\n}`
      );
    }

    // 5–9. “Other” collections (alphabetical; default first)
    for (const col of Object.keys(others).sort()) {
      const sets = others[col];
      const names = Object.keys(sets).sort((a, b) => {
        if (a === "default") return -1;
        if (b === "default") return 1;
        return a.localeCompare(b);
      });
      for (const setName of names) {
        const list = sets[setName];
        const selector =
          setName === "default" ? ":root" : `[data-${kebab(col)}="${setName}"]`;
        out += section(`${col}: ${setName}`, `${selector} {\n${decls(list)}\n}`);
      }
    }

    // 10–11. Mode (light first)
    for (const mName of Object.keys(modes).sort((a, b) => {
      if (a === "light") return -1;
      if (b === "light") return 1;
      return a.localeCompare(b);
    })) {
      const selector = mName === "light" ? ":root" : `[data-mode="${mName}"]`;
      out += section(`mode: ${mName}`, `${selector} {\n${decls(modes[mName])}\n}`);
    }

    // 12. Styles → classes (typography, boxShadow, generic composite)
    const styleTokens = all.filter((t) => isStyles(t) && isComposite(t));
    if (styleTokens.length) {
      out += "/* Styles */\n";
      for (const t of styleTokens) {
        const type = t.type || "";
        const pathKebab = t.path.map(kebab).join("-");
        const v = t.original?.value ?? t.value;

        if (type === "typography" && v && typeof v === "object" && !Array.isArray(v)) {
          const className = `.text-${pathKebab}`;
          const rules = Object.entries(v)
            .map(([k, val]) => `  ${kebab(k)}: ${refToVar(val)};`)
            .join("\n");
          out += `${className} {\n${rules}\n}\n\n`;
          continue;
        }

        if (type === "boxShadow") {
          const className =
            t.path[0] === "elevation" ? `.elevation-${t.path.slice(1).map(kebab).join("-")}` : `.${pathKebab}`;
          const toShadow = (obj) =>
            ["x", "y", "blur", "spread", "color"]
              .map((k) => refToVar(obj?.[k]))
              .filter(Boolean)
              .join(" ");
          const val = Array.isArray(v)
            ? v.map(toShadow).join(", ")
            : typeof v === "object"
            ? toShadow(v)
            : refToVar(v);
          out += `${className} {\n  box-shadow: ${val};\n}\n\n`;
          continue;
        }

        // generic composite class fallback
        if (v && typeof v === "object") {
          const className = `.${pathKebab}`;
          const rules = Object.entries(v)
            .map(([k, val]) => `  ${kebab(k)}: ${refToVar(val)};`)
            .join("\n");
          out += `${className} {\n${rules}\n}\n\n`;
        }
      }
    }

    return out.trim() + "\n";
  },
});

// ---------- export SD config ----------
export default {
  source: ["tokens/raw/**/*.json"],
  platforms: {
    css: {
      transformGroup: "css",
      buildPath: "tokens/resolved/",
      files: [
        {
          destination: "tokens-test.css",
          format: "nw/css-collections",
          options: { outputReferences: true }
        },
      ],
    },
  },
};
