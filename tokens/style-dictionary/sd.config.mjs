import StyleDictionary from "style-dictionary";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = process.cwd();
const RAW_DIR = path.join(REPO_ROOT, "tokens", "raw");

// ---- naming helpers (match your preferred var names) ----
const COLLAPSE = new Map([
  ["fontSize", "fontsize"],
  ["fontFamily", "fontfamily"],
  ["lineHeight", "lineheight"],
  ["letterSpacing", "letterspacing"],
  ["fontStretch", "fontstretch"]
]);
const seg = (s) => COLLAPSE.get(s) ?? String(s).toLowerCase();
const varNameFromPath = (arr) => `--${arr.map(seg).join("-")}`;
const refToVar = (val) => {
  if (typeof val === "string") {
    const m = val.match(/^\{([^}]+)\}$/);
    if (m) return `var(--${m[1].split(".").map(seg).join("-")})`;
  }
  return val;
};

// ---- file utils ----
const readJson = (p) => JSON.parse(fs.readFileSync(p, "utf8"));
const listFiles = (dir) =>
  fs.existsSync(dir)
    ? fs.readdirSync(dir).filter((f) => f.endsWith(".json")).map((f) => path.join(dir, f))
    : [];

const listDirs = (dir) =>
  fs.existsSync(dir)
    ? fs
        .readdirSync(dir, { withFileTypes: true })
        .filter((d) => d.isDirectory())
        .map((d) => d.name)
    : [];

// ---- flatten tokens (DTCG-style) ----
const flattenValues = (obj, prefix = [], out = []) => {
  // “value” node with primitive or string → a var
  if (
    obj &&
    typeof obj === "object" &&
    "value" in obj &&
    (typeof obj.value !== "object" || obj.value === null)
  ) {
    out.push({ path: prefix, value: obj.value });
    return out;
  }

  // walk children
  if (obj && typeof obj === "object" && !Array.isArray(obj)) {
    for (const [k, v] of Object.entries(obj)) {
      if (k === "value") continue; // composite handled elsewhere
      flattenValues(v, prefix.concat(k), out);
    }
  }
  return out;
};

// ---- styles (typography / boxShadow / generic composites) ----
const collectStyleBlocks = (stylesJson) => {
  const blocks = [];

  const walk = (node, p = []) => {
    if (!node || typeof node !== "object") return;

    if (
      "value" in node &&
      node.value &&
      typeof node.value === "object" &&
      !Array.isArray(node.value)
    ) {
      const type = node.type || "";
      const classSuffix = p.map(seg).join("-");
      if (type === "typography") {
        const rules = Object.entries(node.value)
          .map(([k, v]) => `  ${seg(k)}: ${refToVar(v)};`)
          .join("\n");
        blocks.push(`.text-${classSuffix} {\n${rules}\n}`);
        return;
      }
      if (type === "boxShadow") {
        const toShadow = (obj) =>
          ["x", "y", "blur", "spread", "color"]
            .map((k) => refToVar(obj?.[k]))
            .filter(Boolean)
            .join(" ");
        const shadow =
          Array.isArray(node.value)
            ? node.value.map(toShadow).join(", ")
            : toShadow(node.value);
        const cls =
          p[0] === "elevation" ? `.elevation-${p.slice(1).map(seg).join("-")}` : `.${classSuffix}`;
        blocks.push(`${cls} {\n  box-shadow: ${shadow};\n}`);
        return;
      }

      // generic composite → CSS properties
      const rules = Object.entries(node.value)
        .map(([k, v]) => `  ${seg(k)}: ${refToVar(v)};`)
        .join("\n");
      blocks.push(`.${classSuffix} {\n${rules}\n}`);
      return;
    }

    // walk children
    for (const [k, v] of Object.entries(node)) {
      if (k === "value") continue;
      walk(v, p.concat(k));
    }
  };

  walk(stylesJson, []);
  return blocks;
};

// ---- make :root or selector block from a file ----
const varsBlockFromFile = (filePath) => {
  const json = readJson(filePath);
  const vars = flattenValues(json);
  if (!vars.length) return "";

  const body = vars
    .slice()
    .sort((a, b) => varNameFromPath(a.path).localeCompare(varNameFromPath(b.path)))
    .map(({ path: p, value }) => `  ${varNameFromPath(p)}: ${refToVar(value)};`)
    .join("\n");

  return `:root {\n${body}\n}`;
};

// ---- custom format: build the whole CSS in your required order ----
StyleDictionary.registerFormat({
  name: "nw/css-collections",
  format: () => {
    let css = `/* Auto-generated by Style Dictionary. Do not edit directly. */\n\n`;

    // 1) Global
    const globalFiles = listFiles(path.join(RAW_DIR, "global"));
    if (globalFiles.length) {
      css += `/* Base: Global + inline + defaults */\n`;
      for (const f of globalFiles) {
        const block = varsBlockFromFile(f);
        if (block) css += block + "\n\n";
      }
    }

    // 2–4) Breakpoints
    const bpDir = path.join(RAW_DIR, "breakpoint");
    const mobile = path.join(bpDir, "mobile.json");
    const tablet = path.join(bpDir, "tablet.json");
    const desktop = path.join(bpDir, "desktop.json");

    if (fs.existsSync(mobile)) {
      css += `/* Breakpoint default — breakpoint/mobile */\n${varsBlockFromFile(mobile)}\n\n`;
    }
    if (fs.existsSync(tablet)) {
      const inner = varsBlockFromFile(tablet).replace(/^/gm, "  ");
      css += `/* Breakpoint min-width 640px — breakpoint/tablet */\n@media (min-width: 640px) {\n${inner}\n}\n\n`;
    }
    if (fs.existsSync(desktop)) {
      const inner = varsBlockFromFile(desktop).replace(/^/gm, "  ");
      css += `/* Breakpoint min-width 1024px — breakpoint/desktop */\n@media (min-width: 1024px) {\n${inner}\n}\n\n`;
    }

    // 5–9) “Other” collections (everything except global/breakpoint/mode/styles)
    const topDirs = listDirs(RAW_DIR)
      .filter((d) => !["global", "breakpoint", "mode", "styles"].includes(d))
      .sort();
    for (const col of topDirs) {
      const dir = path.join(RAW_DIR, col);
      const files = listFiles(dir).sort(); // alphabetical: default.json first naturally if named default.json

      // default (→ :root) first, then others (→ [data-<collection>="<set>"])
      const def = files.find((f) => path.basename(f).toLowerCase() === "default.json");
      if (def) {
        css += `/* Other ${col} — default */\n${varsBlockFromFile(def)}\n\n`;
      }
      for (const f of files) {
        if (f === def) continue;
        const setName = path.basename(f, ".json");
        const block = varsBlockFromFile(f).replace(/^:root\s+\{/, `[data-${col}="${setName}"] {`);
        css += `/* Other ${col} — set ${setName} */\n${block}\n\n`;
      }
    }

    // 10–11) Mode (light = default → :root; others → [data-mode="…"])
    const modeDir = path.join(RAW_DIR, "mode");
    if (fs.existsSync(modeDir)) {
      const modeFiles = listFiles(modeDir).sort();
      const light = modeFiles.find((f) => path.basename(f).toLowerCase() === "light.json");
      if (light) {
        css += `/* Mode light — mode/light */\n${varsBlockFromFile(light)}\n\n`;
      }
      for (const f of modeFiles) {
        if (f === light) continue;
        const setName = path.basename(f, ".json");
        const block = varsBlockFromFile(f).replace(/^:root\s+\{/, `[data-mode="${setName}"] {`);
        css += `/* Mode ${setName} — mode/${setName} */\n${block}\n\n`;
      }
    }

    // 12) Styles
    const stylesFile = path.join(RAW_DIR, "styles", "styles.json");
    if (fs.existsSync(stylesFile)) {
      const stylesJson = readJson(stylesFile);
      const blocks = collectStyleBlocks(stylesJson);
      if (blocks.length) {
        css += `/* Styles: styles/styles */\n` + blocks.join("\n\n") + "\n\n";
      }
    }

    return css.trim() + "\n";
  },
});

// ---- SD config stays minimal; we only use our custom format ----
export default {
  source: ["tokens/raw/**/*.json"], // still needed; CLI requires a source, but formatter reads raw files itself
  platforms: {
    css: {
      transformGroup: "css",
      buildPath: "tokens/resolved/",
      files: [
        {
          destination: "tokens-test.css",
          format: "nw/css-collections"
        }
      ]
    }
  }
};
