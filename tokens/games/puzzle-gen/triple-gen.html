<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Pattern Matcher</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Fira+Code:wght@400;500&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        
        .code-font {
            font-family: 'Fira Code', monospace;
        }

        /* Custom scrollbar for the output area */
        .custom-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #1f2937; 
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #4b5563; 
            border-radius: 4px;
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #6b7280; 
        }

        /* Loader animation */
        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="h-screen flex flex-col p-4 md:p-8 text-gray-800">

    <div class="max-w-6xl mx-auto w-full h-full flex flex-col gap-6">
        
        <!-- Header -->
        <header class="flex flex-col gap-2">
            <h1 class="text-3xl font-bold text-gray-900">Word Group Finder</h1>
            <p class="text-gray-600">
                Finds triplets (A, B, C) with evenly distributed overlaps (100k each of 4, 3, 2, 1).
            </p>
        </header>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col md:flex-row gap-6 min-h-0">
            
            <!-- Input Section -->
            <div class="flex-1 flex flex-col gap-3 min-h-0">
                <div class="flex justify-between items-end">
                    <label for="inputWords" class="font-semibold text-gray-700">Input Words</label>
                    <span class="text-xs text-gray-500">Separated by spaces, commas, or newlines</span>
                </div>
                <textarea 
                    id="inputWords" 
                    class="flex-1 w-full p-4 rounded-lg border border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 outline-none resize-none shadow-sm transition-all code-font text-sm"
                    placeholder="Paste your list of words here..."
                >anger
germ
ermine
stone
lonely
one
start
art
artist</textarea>
                
                <div class="bg-white p-3 rounded-lg border border-gray-200 shadow-sm flex flex-col gap-3">
                    <button 
                        onclick="runProcessing()" 
                        id="processBtn"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-6 rounded-lg shadow-md transition-colors flex items-center justify-center gap-2"
                    >
                        Find Groups
                    </button>
                </div>
            </div>

            <!-- Output Section -->
            <div class="flex-1 flex flex-col gap-3 min-h-0">
                <div class="flex justify-between items-end">
                    <label class="font-semibold text-gray-700">JSON Output</label>
                    <div class="flex gap-2 items-center">
                         <span id="loadingIndicator" class="hidden"><div class="loader mr-2"></div> Processing...</span>
                         <span id="resultCount" class="text-xs text-gray-500 py-1">Ready</span>
                    </div>
                </div>
                
                <div class="flex-1 relative rounded-lg overflow-hidden shadow-sm border border-gray-700 bg-gray-900">
                    <textarea 
                        id="outputJson" 
                        readonly 
                        class="w-full h-full p-4 bg-gray-900 text-green-400 code-font text-sm resize-none outline-none custom-scroll"
                    ></textarea>
                    
                    <button 
                        onclick="copyToClipboard()" 
                        class="absolute top-4 right-4 bg-gray-700 hover:bg-gray-600 text-white text-xs px-3 py-1.5 rounded border border-gray-600 transition-colors flex items-center gap-2"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                        Copy JSON
                    </button>
                </div>
            </div>

        </div>
    </div>

    <!-- Logic Script -->
    <script>
        function runProcessing() {
            const btn = document.getElementById('processBtn');
            const loader = document.getElementById('loadingIndicator');
            const countLabel = document.getElementById('resultCount');
            const outputArea = document.getElementById('outputJson');
            
            btn.disabled = true;
            btn.classList.add('opacity-75');
            loader.classList.remove('hidden');
            countLabel.textContent = "Analyzing... (100k quota per overlap)";
            outputArea.value = ""; 

            setTimeout(() => {
                try {
                    processWordsPortmanteau();
                } catch (e) {
                    console.error(e);
                    alert("An error occurred. The browser memory might be full.");
                } finally {
                    btn.disabled = false;
                    btn.classList.remove('opacity-75');
                    loader.classList.add('hidden');
                }
            }, 100);
        }

        function processWordsPortmanteau() {
            const rawInput = document.getElementById('inputWords').value;
            
            // --- SETTINGS ---
            const limitPerCategory = 100000; // 100k per overlap length
            const minOverlap = 1; 
            const maxOverlapSearch = 4;
            
            // 1. Parse and Clean Words
            const wordList = rawInput.split(/[\s,]+/)
                .map(w => w.trim().toLowerCase())
                .filter(w => w.length > 0);
            
            const words = [...new Set(wordList)]; 
            const wordSet = new Set(words); 
            
            const groups = [];
            const seenGroups = new Set();
            
            // Quota Tracking
            const counts = {
                4: 0,
                3: 0,
                2: 0,
                1: 0
            };

            // Max word length for iteration safety
            let maxWordLen = 0;
            for(const w of words) {
                if(w.length > maxWordLen) maxWordLen = w.length;
            }

            // 2. Precompute StartsWith Map
            const startsWithMap = new Map();
            words.forEach(w => {
                for (let i = 1; i <= w.length; i++) {
                    const prefix = w.substring(0, i);
                    if (!startsWithMap.has(prefix)) startsWithMap.set(prefix, []);
                    startsWithMap.get(prefix).push(w);
                }
            });

            // 3. Main Loop
            const startLen = Math.min(maxWordLen, maxOverlapSearch);
            
            // Loop from 4 down to 1
            outerLoop:
            for (let len = startLen; len >= minOverlap; len--) {
                
                // PERFORMANCE OPTIMIZATION: 
                // If we already met the quota for this length, SKIP scanning for it entirely.
                // This prevents hanging on 300k lists once we have enough matches.
                if (counts[len] >= limitPerCategory) continue;

                for (const wordA of words) {
                    // Check quota again periodically inside the loop or just rely on the outer skip.
                    // (Outer skip is usually sufficient for major speedups, but checking here breaks early)
                    if (counts[len] >= limitPerCategory) break; 

                    if (wordA.length < len) continue;

                    const overlapStr = wordA.substring(wordA.length - len);
                    
                    const candidatesC = startsWithMap.get(overlapStr);
                    if (!candidatesC) continue;

                    for (const wordC of candidatesC) {
                        if (wordA === wordC) continue;
                        
                        // Constraint 1
                        if (wordA.includes(wordC) || wordC.includes(wordA)) continue;

                        const pPartC = wordC.substring(len);
                        const portmanteau = wordA + pPartC;
                        
                        const overlapStart = wordA.length - len;
                        const overlapEnd = wordA.length;
                        
                        // Find B
                        for (let i = 0; i < portmanteau.length; i++) {
                            for (let j = i + 1; j <= portmanteau.length; j++) {
                                const sub = portmanteau.substring(i, j);
                                
                                if (wordSet.has(sub)) {
                                    const wordB = sub;
                                    
                                    if (wordB === wordA || wordB === wordC) continue;
                                    
                                    // Constraint 2: Start/End unique
                                    const starts = new Set([wordA[0], wordB[0], wordC[0]]);
                                    const ends = new Set([
                                        wordA[wordA.length - 1], 
                                        wordB[wordB.length - 1], 
                                        wordC[wordC.length - 1]
                                    ]);
                                    
                                    if (starts.size !== 3 || ends.size !== 3) continue;

                                    // Constraint 3: Substrings
                                    if (wordA.includes(wordB) || wordB.includes(wordA) ||
                                        wordC.includes(wordB) || wordB.includes(wordC)) {
                                        continue;
                                    }

                                    // Calc Overlap
                                    const intersectStart = Math.max(i, overlapStart);
                                    const intersectEnd = Math.min(j, overlapEnd);
                                    const tripleOverlapCount = Math.max(0, intersectEnd - intersectStart);
                                    
                                    // ADD TO GROUPS LOGIC
                                    // Only add if it falls within our search range AND we have space in quota
                                    if (tripleOverlapCount <= maxOverlapSearch && tripleOverlapCount >= minOverlap) {
                                        
                                        if (counts[tripleOverlapCount] < limitPerCategory) {
                                            const outputKey = `${wordA}-${wordB}-${wordC}`;
                                            
                                            if (!seenGroups.has(outputKey)) {
                                                seenGroups.add(outputKey);
                                                
                                                groups.push({
                                                    words: [wordA, wordB, wordC],
                                                    overlap: tripleOverlapCount
                                                });
                                                
                                                counts[tripleOverlapCount]++;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // 4. Sort Results
            groups.sort((a, b) => {
                if (b.overlap !== a.overlap) {
                    return b.overlap - a.overlap;
                }
                const strA = a.words.join('-');
                const strB = b.words.join('-');
                return strA.localeCompare(strB);
            });

            document.getElementById('outputJson').value = JSON.stringify(groups, null, 4);
            
            const countLabel = document.getElementById('resultCount');
            const totalFound = groups.length;
            
            if (totalFound === 0) {
                countLabel.textContent = "No matches found";
                countLabel.className = "text-xs text-red-500 py-1 font-semibold";
            } else {
                countLabel.textContent = `Found ${totalFound} groups (4s: ${counts[4]}, 3s: ${counts[3]}, 2s: ${counts[2]}, 1s: ${counts[1]})`;
                countLabel.className = "text-xs text-green-600 py-1 font-semibold";
            }
        }

        function copyToClipboard() {
            const copyText = document.getElementById("outputJson");
            copyText.select();
            copyText.setSelectionRange(0, 9999999); 
            
            try {
                document.execCommand('copy');
                const btn = document.querySelector("button[onclick='copyToClipboard()']");
                const originalText = btn.innerHTML;
                btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg> Copied!`;
                setTimeout(() => btn.innerHTML = originalText, 2000);
            } catch (err) {
                console.error('Failed to copy', err);
                alert("Failed to copy. List is too large.");
            }
        }
    </script>
</body>
</html>